<!DOCTYPE html>
<html lang="cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Realtime Data and Image</title>
    <style>

        /* 通用盒模型调整 */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }
        /* 通用样式 */
        body {
            /* background-color: rgb(23, 159, 244); */
            margin: 0 ;/* 清除默认外边距，让内容从边缘开始 */
            text-align: center;/* 文本居中 */
            font-family: Arial, sans-serif;
        }

         .Title {
            width: 100%; /* 宽度充满父容器 */
            height: 10%; /* 高度占页面的10% */
            text-align: center; /* 文本居中 */
            /* font-weight: bold; 字体加粗 */
            color: #29df54; /* 深灰色字体 */
            /* margin-bottom: 1rem; */
            /* border: 3px solid #ddd; 添加边框 */
            /* 添加以下样式以美化标题 */
            background-color: linear-gradient(to right, #91e694, #0a71de); /* 渐变背景色 */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); /* 添加轻微阴影效果 */
        } 

        /* 容器布局 */
        .container {
            display: flex; /* 启用Flexbox布局 */
            justify-content: flex-start; /* 子元素沿主轴（横轴）左对齐 */
            align-items: center; /* 子元素在交叉轴（纵轴）居中对齐 */
            height: 90%; /* 容器高度占页面的90% */
            width: 100%;
        }

        /* 图片部分 */
        .image-container {
            flex: 0 0 80%; /* 图片宽度固定为75%，不参与弹性分配 */
            position: relative; /* 便于图片内部的绝对定位 */
            padding: 0.5%; 
            border: 3px solid #ddd; /* 添加边框 */
            border-radius: 10px; /* 增加圆角 */
            box-shadow: 0 10px 4px rgba(0, 0, 0, 0.1); /* 添加阴影 */
        }

        .image-container img {
            width: 100%; /* 宽度填充容器 */
            height: auto; /* 高度自适应以保持图片比例 */    
            object-fit: cover; /* 保持图片宽高比并填充容器 */
            
        }

        /* 数据部分 */
        .data-container {
            display: flex; /* 创建弹性盒子模型 */
            flex-direction: column; /* 设置方向为列，以垂直排列内部元素 */
            justify-content: center; /* 垂直居中对齐 */
            /* align-items: center; 水平居中对齐，如果按钮和数据文本需要水平居中的话 */
            flex: 0 0 20%; /* 数据区域宽度固定为40%，不参与弹性分配 */
            /* border: 3px solid #ddd; 添加边框 */
            /* padding-left: 20px; 添加适当内边距与图片区隔开 */
            /* background-color: #f9f9f9;
            padding: 20px;
            /* border-radius: 5px; */
            /* box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); */
            /* margin-right: 20px; 与图片容器间距 */ 
        }
        
        

        /*按钮部分*/
        button {
            display: block;
            margin: 10px auto;
            /* padding: 10px 20px; */
            width: 200px; 
            height: 60px; 
            font-size: 40px;
            color: white;
            background-color: #007BFF;
            border: none;
            cursor: pointer;
            border-radius: 10px; /* 增加圆角 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* 添加阴影 */
            transition: background-color 0.3s ease; /* 添加过渡效果 */
        }
        /*悬停时，按钮变色*/
        button:hover {
            background-color: #519cec;
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2); /* 鼠标悬停时加深阴影 */
        }

        /* 新增CSS类用于弹窗样式和隐藏/显示控制 */
        .hidden {
            display: none;
        }

        .alert-box {
            position: fixed; /* 固定位置 */
            top: 50%; /* 居中显示 */
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(249, 247, 247, 0.915); /* 半透明黑色背景 */
            /* background-color: #f9f9f9; */
            color: #000;
            padding: 20px; /* 内边距 */
            border-radius: 5px; /* 圆角 */
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2); /* 阴影效果 */
            z-index: 100; /* 确保在最上层 */
            width: 8%; /* 弹窗宽度，可根据需要调整 */
            animation: fadeIn 0.5s forwards; /* 动画淡入 */
        }
        /* 弹窗渐显动画 */
        @keyframes fadeIn {
            0% {opacity: 0;}
            100% {opacity: 1;}
        }  

    </style>
</head> 
<body>
    <div class="Title">
        <h1>光伏板故障检测系统</h1>
    </div>
    
    <div class="container">
        <div class="image-container">
            <img id='image-display' src="{{ url_for('video_feed') }}"  alt="实时图像" />
        </div>
        <div class="data-container">
            <button type="button" onclick="sendButtonEventToServer('car', 'start')">小车启动</button>
            <button type="button" onclick="sendButtonEventToServer('car', 'stop')">小车停止</button>
            <button type="button" onclick="sendButtonEventToServer('detect', 'start')">检测开始</button>
            <button type="button" onclick="sendButtonEventToServer('detect', 'stop')">停止检测</button>
            <div id="data"></div>
        </div>
    </div>

    <!-- 在body标签内新增弹窗结构 -->
    <div id="custom-alert" class="alert-box hidden">
        小车成功启动
    </div>

    <script>
        // 封装发送开始请求的函数
        async function sendButtonEventToServer(action, key) {
            try {
                const response = await fetch('/button', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: action,
                        key: key
                    })
                });
                const data = await response.json();
                if (data.status !== 'success') {
                    console.error("Failed to send key event to server");
                }
                else {
                    console.log("POST请求成功");
                    // 显示自定义弹窗
                    var alertBox = document.getElementById('custom-alert');
                    alertBox.textContent="操作成功";
                    alertBox.classList.remove('hidden'); // 移除hidden类以显示弹窗

                    // 定时器自动隐藏弹窗并移除
                    setTimeout(function() {
                        alertBox.classList.add('hidden'); // 添加hidden类以隐藏弹窗
                    }, 2000); // 2000毫秒后自动隐藏，即2秒
                }
            } catch (error) {
                console.error("Error sending key event:", error);
            }
        }
    
        // 初始化EventSource以监听服务器推送的实时数据
        var source = new EventSource('/data');
    
        // 处理接收到的消息
        source.addEventListener('message', function(event) {
            document.getElementById('data').innerText = event.data; // 显示实时数据文本
        });
    
        // 错误监听
        source.addEventListener('error', function(event) {
            console.error('EventSource连接遇到错误:', event);
            // 这里可以处理重连逻辑或提示用户
        });


        function saveImage() {
            
            // 创建隐藏的链接元素用于下载
            var downloadLink = document.createElement('a');
            downloadLink.href = document.getElementById('image-display').src;
            downloadLink.download = 'saved-image.jpg'; // 自定义下载的文件名和格式
            
            // 触发点击下载链接
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink); // 下载后移除隐藏的链接
        }


        async function sendKeyEventToServer(action, key) {
            try {
                const response = await fetch('/keypress', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: action,
                        key: key
                    })
                });
                const data = await response.json();
                if (data.status !== 'success') {
                    console.error("Failed to send key event to server");
                }
            } catch (error) {
                console.error("Error sending key event:", error);
            }
        }

        document.addEventListener('DOMContentLoaded', async function() {
            var keysDown = {}; // 用于记录当前按下的键

            let isKeyDown = {}; // 用于记录每个键是否已经发送过keydown请求

            document.addEventListener('keydown', function(event) {
                var key = event.key.toUpperCase();
                if (event.key === 'Enter') {
                    event.preventDefault(); // 防止默认的回车键行为（如表单提交）
                    saveImage();
                }
                if ('WASD'.includes(key) && !isKeyDown[key]) { // 确保每个键的keydown只触发一次
                    event.preventDefault();
                    keysDown[key] = true;
                    sendKeyEventToServer('keydown', key).then(() => {
                        isKeyDown[key] = true; // 发送成功后标记此键已发送keydown
                    }).catch(console.error);
                }
            });
            // 键盘抬起事件
            document.addEventListener('keyup', function(event) {
            var key = event.key.toUpperCase();
            if (key in keysDown) {
                delete keysDown[key];
                sendKeyEventToServer('keyup', key).then(() => {
                    isKeyDown[key] = false; // 重置标记，允许下次keydown发送请求
                }).catch(console.error);
            }
        });

            
        });
    </script>
</body>
</html>
